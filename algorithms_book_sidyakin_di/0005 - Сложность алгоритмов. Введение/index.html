<!DOCTYPE html>
<html>
<head>
<title>Алгоритмы - Сложность алгоритмов. Введение</title>
<link rel="stylesheet" type="text/css" href="../../css/main.css">
</head>
<body>
<a href="https://dmitriysidyakin.github.io/School-IT/algorithms_book_sidyakin_di/">Набор олгоритмов</a>
<p>
Статья посвящена тому, как сравнивать алгоритмы. Статья позволит определять математическую сложность алгоритмов. Возможно это не поможет сделать Ваш алгоритм оптимальным, т.к. он уже оптимальный, но даст Вам возможность определить узкие места, что позволит: более правильно разбить алгоритм по реальной, конечной (для Вас) электронике; изменить тип входных данных; изменить человеко-машинный интерфейс программы, и т.п.</p>
<img src="../img/algorithms_logo_blogger.png"/>
<h1>Алгоритмы - Сложность алгоритмов. Введение</h1>
<ul class="noneVisibleMarkers">
<li><a href="#Base">1. Основы оценки математической сложности алгоритмов.</a></li>
<li><a href="#RealElectronics">2. Оценка алгоритмов на реальной электронике.</a></li>
<li><a href="#MainAxioms">3. Основные аксиомы.</a>
<ul class="noneVisibleMarkers">
<li><a href="#Axiom1">3.1. Аксиома 1: Равенство.</a></li>
<li><a href="#Axiom2">3.2. Аксиома 2: Прямое действие управляющего глагола.</a></li>
<li><a href="#Axiom3">3.3. Аксиома 3: Фрагментация.</a></li>
<li><a href="#Axiom4">3.4. Аксиома 4: Передача результата.</a></li>
</ul></li>
<li><a href="#ConclusionAndWishes">4. Заключение и пожелания.</a></li>
</ul>
<h2 id="Base">1. Основы оценки математической сложности алгоритмов.</h2>
<p>Математическая сложность алгоритма равна сумме весов всех операций процессора выполняемых от начала алгоритма до его отработки.</p>
<p>Пусть в алгоритме используются следующие операции с указанными весами, для примера.</p>
<p>
<table cellpadding="0" cellspacing="0" border="1">
<tr class="rowedTable-notEvenRow"><td><b>П.п.</b></td><td><b>Вес операции</b></td><td><b>Операция</b></td></tr>
<tr class="rowedTable-evenRow"><td>1</td><td>1</td><td>+</td></tr>
<tr class="rowedTable-notEvenRow"><td>2</td><td>1</td><td>-</td></tr>
<tr class="rowedTable-evenRow"><td>3</td><td>1</td><td>Вызов</td></tr>
<tr class="rowedTable-notEvenRow"><td>4</td><td>1</td><td>/</td></tr>
<tr class="rowedTable-evenRow"><td>5</td><td>1</td><td>*</td></tr>
<tr class="rowedTable-notEvenRow"><td>6</td><td>1</td><td>Присвоение, =</td></tr>
<tr class="rowedTable-evenRow"><td>7</td><td>1</td><td>&lt;</td></tr>
<tr class="rowedTable-notEvenRow"><td>8</td><td>1</td><td>&gt;</td></tr>
<tr class="rowedTable-evenRow"><td>9</td><td>1</td><td>==</td></tr>
<tr class="rowedTable-notEvenRow"><td>10</td><td>1</td><td>!=</td></tr>
<tr class="rowedTable-evenRow"><td>11</td><td>1</td><td>&lt;=</td></tr>
<tr class="rowedTable-notEvenRow"><td>12</td><td>1</td><td>&gt;=</td></tr>
<tr class="rowedTable-evenRow"><td>13</td><td>1</td><td>Возврат</td></tr>
<tr class="rowedTable-evenRow"><td>14</td><td>1</td><td>Чтение переменной</td></tr>
<tr class="rowedTable-notEvenRow"><td>15</td><td>В зависимости от тела функции</td><td>Выполнение функции</td></tr>
<tr class="rowedTable-evenRow"><td>16</td><td>В зависимости от цикла (сложность тела цикла * количество повторений)</td><td>Выполнение цикла</td></tr>
<tr class="rowedTable-notEvenRow"><td>17</td><td>И т.п.</td><td>И т.д.</td></tr>
</table></p>
<p>Сам алгоритм таков:</p>
<p><div class="commands">
function int main(){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return f1();<br/>
}<br/><br/>
function int f1() {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int result = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 1; i &lt;= 5; i = i + 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = result + 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return result;<br/>
}<br/>
</div>
</p>
<p>Оценим сложность вышеприведённой функции main:</p>
<p><table cellpadding="0" cellspacing="0" border="1">
<tr class="rowedTable-notEvenRow"><td><b>П.п.</b></td><td><b>Вес операции</b></td><td><b>Операция</b></td></tr>
<tr class="rowedTable-evenRow"><td>1</td><td>1</td><td>Возврат</td></tr>
<tr class="rowedTable-notEvenRow"><td>2</td><td>В зависимости от тела функции</td><td>Выполнение функции</td></tr>
</table></p>
<p>Оценим сложность выполнения функции f1:</p>
<p><table cellpadding="0" cellspacing="0" border="1">
<tr class="rowedTable-notEvenRow"><td><b>П.п.</b></td><td><b>Вес операции</b></td><td><b>Операция</b></td><td><b>Строка</b></td></tr>
<tr class="rowedTable-evenRow"><td>1</td><td>1</td><td>Присвоение</td><td>int result = 0;</td></tr>
<tr class="rowedTable-notEvenRow"><td>2</td><td>1</td><td>Присвоение</td><td>for(<b>int i = 1</b>; i &lt;= 5; i = i + 1) {</td></tr>
<tr class="rowedTable-notEvenRow"><td>3</td><td>1</td><td>Чтение переменной i</td><td>for(int i = 1; <b>i</b> &lt;= 5; i = i + 1) {</td></tr>
<tr class="rowedTable-evenRow"><td>4</td><td>1</td><td>&lt;=</td><td>for(int i = 1; <b>i &lt;= 5</b>; i = i + 1) {</td></tr>
<tr class="rowedTable-evenRow"><td>5</td><td>1</td><td>Чтение переменной result</td><td>result = <b>result</b> + 2;</td></tr>
<tr class="rowedTable-notEvenRow"><td>6</td><td>1</td><td>+</td><td>result = result <b>+</b> 2;</td></tr>
<tr class="rowedTable-evenRow"><td>7</td><td>1</td><td>Присвоение, =</td><td>result <b>=</b> result + 2;</td></tr>
<tr class="rowedTable-notEvenRow"><td>8</td><td>1</td><td>Чтение переменной i</td><td>i = <b>i</b> + 1</td></tr>
<tr class="rowedTable-evenRow"><td>9</td><td>1</td><td>+</td><td>i = i <b>+</b> 1</td></tr>
<tr class="rowedTable-notEvenRow"><td>10</td><td>1</td><td>Присвоение, =</td><td><b>i =</b> i + 1</td></tr>
<tr class="rowedTable-evenRow"><td>11-34</td><td>24</td><td>Повторение операций подпунктов [3, 4, 5, 6, 7, 8, 9, 10] 4 раза.</td><td></td></tr>
<tr class="rowedTable-notEvenRow"><td>35</td><td>1</td><td>Чтение переменной i</td><td>for(int i = 1; <b>i</b> &lt;= 5; i = i + 1) {</td></tr>
<tr class="rowedTable-evenRow"><td>36</td><td>1</td><td>&lt;=</td><td>for(int i = 1; <b>i &lt;= 5</b>; i = i + 1) {</td></tr>
<tr class="rowedTable-evenRow"><td>37</td><td>1</td><td>Возврат</td><td>return result;</td></tr>
</table></p>
<p>Итого сложность выполнения вышеописанного метода main: 1 + 37 = <b>38</b>.</p>
<p>Оптимизируем алгоритм main:</p>
<p><div class="commands">
function int main(){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return f1();<br/>
}<br/><br/>
function int f1() {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 2*5;<br/>
}<br/>
</div></p>
<p>Или:</p>
<p><div class="commands">
function int main(){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 10;<br/>
}<br/><br/>
</div></p>
<p>Как видно из оптимизации сложность оптимизированного алгоритма равна <b>1</b> - Т.е. изначально алгоритм был не правильный. - Выбирайте за что платить, за количество строк в алгоритме или за информативность одной строки. Выберите платить за "и": и за то, и за то (за количество информативных строк). Но для этого нужны исследования, а не программирование на время за человекочас, поэтому лучше выбирать среднее, но в будущем Вы обязательно его оптимизируете.</p>
<h2 id="RealElectronics">2. Оценка алгоритмов на реальной электронике.</h2>
<p>На реальной электронике вес выполнения одной операции может быть различен, не равен всегда единице, т.к. оперативная память медленнее регистров процессора, жёсткий диск медленнее оперативной памяти, сеть медленнее жёсткого диска. Поэтому проверяйте среднее время выполнения на реальной элетронике.</p>
<p>Для проведения тестов всего лишь нужно запустить тест на время выполнения много раз, получив статистику, Вы можете определить среднее время выполнения - Это делает алгоритмы сравнимыми тоже.</p>
<p>Для проведения этих тестов можно использовать разницу времени входа в метод и выхода. Или среду тестирования.</p>
<h2 id="MainAxioms">3. Основные аксиомы.</h2>
<p>В данном разделе полученные опытом разработки напутствия для концентрирования Вашего внимания на аспектах разработки алгоритмов.</p>
<h3 id="Axiom1">3.1. Аксиома 1: Равенство.</h3>
<p>Это оптимальный алгоритм?</p>
<div class="information">
 <p><b>Аксиома 1: Равенство</b>: Если разделить на объекты, то есть одинаковый по сложности путь решения математической задачи на процессоре. Т.е. если одинаковое дано, и одинаковый тип входных данных, и дальнейшее утверждения верно для одного процессора - в этом случае алгоритмы равны и не могут быть разными.</p>
</div>
<p>
Эта аксиома верна при логическом написании кода программы. Т.е. если Вы не делаете 2-2, чтобы объявить нуль, но и тут может помочь оптимизатор. Есть способ оптимизации по реальной электронике: изменить тип данных (разбить хранение одних данных на одном компьютере, другой категории на другом), увеличить, в любом случае, мощность серверов, изменить интерфейс программы и т.п.
</p>
<h3 id="Axiom2">3.2. Аксиома 2: Прямое действие управляющего глагола.</h3>
<p>Это та программа?</p>
<div class="information">
 <p><b>Аксиома 2: Прямое действие управляющего глагола</b>: Если Ваша программа делает то, что обещала, то не занимайтесь оптимизацией за миллисекунды, оптимизация начинается за существенное время. Если программа, допустим, распознаёт текст на персональном компьютере, а программа работает быстрее только если увеличить вычислительную мощность, то смело ставьте полосу ожидания.</p>
</div>
<p>
Это значит, что приоритетнее ввод нового функционала в программу, нежели борьба за миллисекунды. Но это не значит, что, как пример, Вы не будете менять интерфейс программы, который повлияет на скорость обработки данных на многоядерных системах.
</p>
<h3 id="Axiom3">3.3. Аксиома 3: Фрагментация.</h3>
<p>Это быстрая программа?</p>
<div class="information">
 <p><b>Аксиома 3: Фрагментация</b>: Это разбиение программы и данных на независимые блоки. Не путайте с кластеризацией, где есть общая шина.</p>
</div>
<p>
Это может быть, к примеру, разделение пользовательского интерфейса по серверам: для интернета магазина, одежда храниться на одном сервере, хозтовары - на другом, но в целом это один домен сервера. 
</p>
<h3 id="Axiom4">3.4. Аксиома 4: Передача результата.</h3>
А как? Это реальная электроника!
<div class="information">
 <p><b>Аксиома 4: Передача результата</b>: К примеру, с планеты на планету передают не весь госреестр, а только результат с подписью, для принятия сложных и быстрых решений.</p>
</div>
<p>
Этот результат со всех планет обрабатывается общей шиной, но фрагментирован по планетам.
</p>
<h2 id="ConclusionAndWishes">4. Заключение и пожелания.</h2>
<p>Пишите свои программы, как понимаете, главное выполнение прямого результата действия программы в установленные (допустимые) сроки.
В конце, как получите прямой результат, вы можете оптимизировать программу. Но в этом направлении главное не забывать ознакомиться с предметной областью программы.</p>

</body>
</html>
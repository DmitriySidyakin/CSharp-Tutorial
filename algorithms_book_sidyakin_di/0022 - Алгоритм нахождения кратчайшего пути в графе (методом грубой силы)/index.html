<html>
<head>
<title>Алгоритмы - Алгоритмы нахождения кратчайшего пути в графе</title>
<link rel="stylesheet" type="text/css" href="../../css/main.css">
</head>
<body>
<a href="https://dmitriysidyakin.github.io/School-IT/algorithms_book_sidyakin_di/">Набор Алгоритмов</a>
<p>Нахождение кратчайшего пути в графе. Алгоритмы нахождения самого короткого пути в графе между двум точками (вершинами), в котором находится минимальная сумма весов (рёбер), а также представлены алгоритмы не только для взвешенных графов. В статье дана общая концепция алгоритмов и примеры их реализации.</p>
<img src="../img/algorithms_logo_blogger.png"/>
<h1>Алгоритмы - Алгоритм нахождения кратчайшего пути в графе (в обычном, взвешенном, (дву)направленном), Алгоритм нахождения кратчайшего пути в графе (методом грубой силы)</h1>
<ul class="noneVisibleMarkers">
<li><a href="#Intro">1. Введение</a>

<ul class="noneVisibleMarkers">
<li><a href="#WhatIsGraph">1.1. Что такое граф?</a>

<ul class="noneVisibleMarkers">
<li><a href="#Graph">1.1.1. Граф</a></li>
<li><a href="#GraphS">1.1.2. Направленный (ориентированный) граф</a></li>
<li><a href="#GraphW">1.1.3. Взвешенный граф</a></li>
<li><a href="#GraphSW">1.1.4. Взвешенно-ориентированный (взвешенно-направленый) граф</a></li>
<li><a href="#GraphB">1.1.5. Бинарный граф</a></li>
<li><a href="#Tree">1.1.6. Что такое дерево, как структура?</a></li>
<li><a href="#Summary">1.1.7. Сводка</a></li>
</ul>

</li>
</ul>

</li>
<li><a href="#GraphAlgorithms">2. Графовые алгоритмы
<ul class="noneVisibleMarkers">
<li><a href="#GraphAlgorithms-breadth-first-search">2.1. Поиск в ширину</a></li>
<li><a href="#GraphAlgorithms-depth-first-search">2.2. Поиск в глубину</a></li>
<li><a href="#GraphAlgorithms-Conclusion">2.3. Заключение раздела</a></li>
</ul>
</li>
<li><a href="#AlgorithmForFindingTheShortestPathInAGraph">3. Алгоритм нахождения кратчайшего пути в графе (методом грубой силы)</a></li>
<li><a href="#Conclusion">4. Заключение</a></li>
</ul>
<h2 id="Intro">1. Введение</h2>
<p>В статье описаны разные типы графов и универсильный способ нахождения кратчайшего пути в этом типе графа метожом грубой силы, т.е. алгоритмы нахождения самого короткого пути в графе между двум точками (вершинами, узлами).</p>
<h3 id="WhatIsGraph">1.1. Что такое граф?</h3>
<h4 id="Graph">1.1.1. Граф</h4>
<p>Граф состоит из точек (узлов) <i>(V, Vertex)</i> и рёбер <i>(E, Edge)</i>, соединяющих вершины. Вот пример графа:</p>
<img src="img/graph.svg" />
<p><i>Рис. 1. Пример графа.</i></p>
<h4 id="GraphS">1.1.2. Направленный (ориентированный) граф</h4>
<p>Направленный граф или ориентированный граф имеет помимо структуры обычного графа направление, у ребра соединяющего вершины. У ориентированного графа эти рёбра называются дугами. Он бывает однонаправленный и двунаправленный. Однонаправленным называется граф, содержащий одно направление перехода от одной вершины к другой. Ребра двунаправленного графа содержат одно направление перехода или возможность перехода в обе стороны.</p>
<p>Вот пример однонаправленного графа:</p>
<img src="img/graph-s.svg" />
<p><i>Рис. 2. Пример однонаправленного графа.</i></p>
<p>Далее приведёт пример двунаправленного графа:</p>
<img src="img/graph-d.svg" />
<p><i>Рис. 3. Пример двунаправленного графа.</i></p>
<h4 id="GraphW">1.1.3. Взвешенный граф</h4>
<p>Взвешенны граф &mdash; это граф, у которого у рёбер есть вес соединения вершин <i>W</i>.</p>
<img src="img/graph-w.svg" />
<p><i>Рис. 4. Пример взвешенного графа.</i></p>
<h4 id="GraphSW">1.1.4. Взвешенно-ориентированный (взвешенно-направленый) граф</h4>
<p>Взвешенно-ориентированный (взвешенно-направленый) &mdash; это граф, имеющий помимо вершин, рёбер и направлений ещё и вес направленного ребра.</p>
<p>Вот пример однонаправленного взвешенного графа:</p>
<img src="img/graph-sw.svg" />
<p><i>Рис. 5. Пример однонаправленного взвешенного графа.</i></p>
<p>Далее приведёт пример двунаправленного взвешенного графа:</p>
<img src="img/graph-dw.svg" />
<p><i>Рис. 6. Пример двунаправленного взвешенного графа.</i></p>
<h4 id="GraphB">1.1.5. Бинарный граф</h4>
<p>Бинарный граф &mdash; это граф, у которого одна вершина имеет два ребра.</p>
<p>Пример:</p>
<img src="img/graph-b.svg" />
<p><i>Рис. 7. Пример бинарного графа.</i></p>
<p>Он тоже может быть взвешенным, направленным (ориентированным), двунаправленным (ориентированным в обе стороны).</p>
<h4 id="Tree">1.1.6. Что такое дерево, как структура?</h4>
<p>Дерево &mdash; это граф, у которого между двумя любыми вершинами есть маршрут и нет циклических связей между вершинами. Если удалить любой узел дерева, то это нарушит его связанность.</p>
<p>Термины деревьев:</p>
<ul>
	<li>Корень &mdash; входной узел графа.</li>
	<li>Листья  &mdash; свисающие окончания графа.</li>
	<li>Ветви &mdash; узлы не относящиеся к листьям и корню.</li>
</ul>
<p>Лес &mdash; это множество деревьев.</p>
<p>Пример:</p>
<img src="img/graph-tree.svg" />
<p><i>Рис. 8. Пример дерева.</i></p>
<p>Пример графа, не являющегося деревом, с циклическими связями:</p>
<img src="img/graph-cyclical.svg" />
<p><i>Рис. 9. Граф, не являющейся деревом, с циклическими связями.</i></p>
<p>Свойства деревьев:</p>
<ul>
	<li>Каждое дерево из <i>n</i> узлов (вершин) содержит ровно <i>n - 1</i> ребро.</li>
	<li>G &mdash; ненаправленный (неориентированный) граф c <i>n</i> узлами. Если истинны любые два из следующих утверждений, то автоматически выполняется и третье:
	<ul>
		<li>Граф G является связанным.</li>
		<li>Граф G не содержит циклов.</li>
		<li>Граф G содержит <i>n - 1</i> ребро.</li>
	</ul>
	</li>
</ul>
<h4 id="Summary">1.1.7. Сводка</h4>
<p>Подытожим описанное ранее и дадим дополнение.</p>
<p>Граф &mdash; это математическая модель объектов реальной природы, которые имеют между собой связи. Каждый раф <i>G</i> состоит из набора узлов <i>V (Vertex)</i> и набора направленных рёбер <i>E (Edge)</i>.
Каждое ребро <img src="img/f01eE.PNG" /> и представляется упорядоченной парой (<i>u</i>, <i>v</i>), узел <i>u</i> называется начальным, узел <i>v</i> &mdash; конечным.</p>
<p>Виды графов (рассмотренные ранее):</p>
<ul>
	<li>обычный;</li>
	<li>направленный (ориентированный) граф;</li>
	<li>взвешенный;</li>
	<li>бинарный;</li>
	<li>дерево.</li>
</ul>
<p>Виды графов (дополнение):</p>
<ul>
	<li>циклический (с кольцевыми связями);</li>
	<li>ациклический (без кольцевых связей);</li>
	<li>связанный, когда для любых вершин <i>u</i>, <i>v</i> есть путь из <i>u</i> в <i>v</i>.</li>
</ul>
<p>Граф может иметь совмещённые виды, допустим, взвешенно-направленый или бинарное дерево.</p>
<p>Областей применения графов довольно много: в логистике и транспорте, для описания маршрутов; в интернете, для создания индекса цитирования; в социологии/в социальных сетях, для установления связей между людьми и т.д.</p>
<h2 id="GraphAlgorithms">2. Графовые алгоритмы</h2>
<p>Основной задачей работы с графами является обход узлов, связанных рёбрами. Не направленный граф называется <i>связанным</i>, если из каждой пары узлов <i>u</i> и <i>v</i> существует путь из <i>u</i> в <i>v</i>. Для направленных графов определение даётся по другому: направленный граф называется <i>сильно связанным</i>, если для кажой пары узлов <i>u</i>, <i>v</i> существует путь из <i>u</i> в <i>v</i>, и путь из <i>v</i> в <i>u</i>. Для ненаправленных графов, <i>кратчайший путь</i> между двумя узлами <i>e<sub>x</sub></i> и <i>e<sub>y</sub></i> определяется, как минимальное количество ребёр в пути <i>u-v</i>. Граф называется <i>взвешанным</i>, если для каждого ребра <i>v</i> и/или <i>u</i> есть вес <i>w</i> перехода по этому ребру. <i>Кратчайшим путём для взвешенного графа</i> называется путь с минимальной суммой весов <i>w<sub>i</sub></i> ребёр в пути <i>u-v</i>.</p>
<p>На следующем графе рассмотрим концепции обхода графов:</p>
<img src="img/fs-graph.svg" />
<p>Рис. 10. Граф для обхода.</p>
<p>Далее рассмотрим на этом графе концепцию обхода графа в ширину и глубину. Эти алгоритмы нужны для проверки связанности ненаправленных графов, есть и другие применения.</p>
<h3 id="GraphAlgorithms-breadth-first-search">2.1. Поиск в ширину</h3>
<p><b>Алгоритм поиска в ширину</b> (англ. breadth-first search, BFS) &mdash; позволяет просмотреть все вершины графа.</p>
<p>Рассмотрим последовательность обхода графа:</p>
<img src="img/bfs-graph.svg" />
<p><i>Рис. 11. Последовательность обхода поиском в ширину.</i></p>
<h3 id="GraphAlgorithms-depth-first-search">2.2. Поиск в глубину</h3>
<p><b>Алгоритм поиска в глубину</b> (англ. depth-first search, DFS) &mdash; один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно.</p>
<img src="img/dfs-graph.svg" />
<p><i>Рис. 12. Последовательность обхода поиском в глубину.</i></p>
<h3 id="GraphAlgorithms-Conclusion">2.3. Заключение раздела</h2>
<p>Далее рассматривается алгоритм нахождения кратчайшего пути в графе методом грубой силы.</p>
<h2 id="AlgorithmForFindingTheShortestPathInAGraph">3. Алгоритм нахождения кратчайшего пути в графе (методом грубой силы)</h2>
<p>Для начала рассмотрим, что такое кратчайший путь в графе.</p>
<p>Путь строиться путь от начального узла до конечного, что является входными данными (начальный и конечный узел). Кратчайший путь в ызвешенном графе называется путь с наименьшим количеством рёбер от начального узла до конечного.</p>
<p>Рассмотрим пример кратчайшего пути в графе:</p>
<img src="img/shortest-way-graph.svg" />
<p><i>Рис. 13. Кратчайший путь в графе</i>.</p>
<p>Кратчайшим путём в взвешенном графе является путь с наименьшей суммой весов рёбер.</p>
<p>Рассмотрим пример кратчайшего пути в взвешенном графе:</p>
<img src="img/shortest-way-wgraph.svg" />
<p><i>Рис. 14. Кратчайший путь в взвешенном графе</i>.</p>
<p>Кратчайший путь в ориентированном графе &mdash; это достижимый путь с наименьшим количеством рёбер.</p>
<p>Кратчайший путь в взвешенном ориетированном графе &mdash; это достижимый путь с наименьшей суммой весов рёбер.</p>
<p>Рассмотрим пример кратчайшего пути в взвешенном ориентированном графе:</p>
<img src="img/shortest-way-wograph.svg" />
<p><i>Рис. 15. Кратчайший путь в взвешенном ориентированном графе.</i></p>
<p>Далее описан алгоритм нахождения кратчайшего пути в графе на основе поиска всех ациклических путей методом грубой силы:</p>
<div class="commands2">
<!--<span class="blue">function</span> <i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt; НайтиВсеМаршруты(
            <i>Число</i> ВесТекущегоПути,
            <i>Список</i>&lt;<i>Узел</i>&gt;> ТекущийПуть,
            <i>Узел</i> НачальныйУзел,
            <i>Узел</i> КонечныйУзел)
{
	ТекущийПуть.Добавить(НачальныйУзел);

	<i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt; aциклическиеПути = <span class="blue">new</span> <i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt;;

	<i>Число</i> весТекущегоРузельтата = ВесТекущегоПути;

	<span class="blue">if</span> (НачальныйУзел.Id != НачальныйУзел.Id && НачальныйУзел.КоличествоГраней > 0)
	{
		<span class="blue">for</span> (<i>Число</i> i = 0; i &lt; НачальныйУзел.КоличествоГраней; i++)
		{
			<span class="blue">var</span> грань = НачальныйУзел.Грани[i];

			<i>// Избежание циклических связей</i>
			<i>if</i> (ТекущийПуть.Contains(грань.To))
			{
				<span class="blue">continue</span>;
			}
				
			aциклическиеПути.AddRange(
				НайтиВсеМаршруты(весТекущегоРузельтата + грань.Вес /* или 1 в невзвешенном графе */
				, ТекущийПуть.Копия, грань.To, КонечныйУзел)
				); 
		}

		<span class="blue">return</span> aциклическиеПути;
	}
	<span class="blue">else</span>
	{
		<span class="blue">if</span> (КонечныйУзел.Id != НачальныйУзел.Id)
			<span class="blue">return</span> aциклическиеПути;

		aциклическиеПути.Add((ТекущийПуть, весТекущегоРузельтата));
		<span class="blue">return</span> aциклическиеПути;
	}

}-->

<span class="blue">function</span>(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>) НайтиМинимальныйПуть(<i>Узел</i> НачальныйУзел, <i>Число</i> <i>Узел</i> КонечныйУзел)<br/>
{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt; пути = НайтиВсеМаршруты(<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;0,<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">null</span>,<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Узел</i> НачальныйУзел,<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Узел</i> КонечныйУзел)<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">return</span> ПутьСМинимальнымВесом(пути);<br/>
}<br/>
<br/>
<span class="blue">function</span> <i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt; НайтиВсеМаршруты(<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Число</i> ВесТекущегоПути,<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Список</i>&lt;<i>Узел</i>&gt; ТекущийПуть,<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Узел</i> НачальныйУзел,<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>Узел</i> КонечныйУзел)<br/>
{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;ТекущийПуть.Добавить(НачальныйУзел);<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt; aциклическиеПути = <span class="blue">new</span> <i>Список</i>&lt;(<i>Список</i>&lt;<i>Узел</i>&gt;, <i>Число</i>)&gt;;<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<i>Число</i> весТекущегоРузельтата = ВесТекущегоПути;<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">if</span> (НачальныйУзел.Id != НачальныйУзел.Id && НачальныйУзел.КоличествоГраней > 0)<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">for</span> (<i>Число</i> i = 0; i &lt; НачальныйУзел.КоличествоГраней; i++)<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">var</span> грань = НачальныйУзел.Грани[i];<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>// Избежание циклических связей</i><br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">if</span> (ТекущийПуть.Contains(грань.To))<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">continue</span>;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;aциклическиеПути.AddRange(<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;НайтиВсеМаршруты(весТекущегоРузельтата + грань.Вес /* или 1 в невзвешенном графе */<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;, ТекущийПуть.Копия, грань.To, КонечныйУзел)<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;); <br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">return</span> aциклическиеПути;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">else</span><br/>
 &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">if</span> (КонечныйУзел.Id != НачальныйУзел.Id)<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">return</span> aциклическиеПути;<br/>
<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;aциклическиеПути.Add((ТекущийПуть, весТекущегоРузельтата));<br/>
 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="blue">return</span> aциклическиеПути;<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
}<br/>
</div>
<p>Этим алгоритмом можно искать пути в обычном графе, взвешенном и направленном.</p>
<p>Приведённый метод возвращает все ациклические пути и их вес. Достаточно выбрать путь с наименьшим весом. Этот алгоритм основан на методе с грубой силой (просмотре всех возможных ациклических путей и выбора наименьшего).</p>
<p>Концепция состоит в том, чтобы обойти все возможные ациклические маршруты и сохранить для каждого найденного вес, потом найти минимальный вес:</p>
<img src="img/find-shortest-ways.gif" />
<p><i>Анимация 1. Обход всех путей графа.</i></p>
<h2 id="Conclusion">4. Заключение</h2>
<p>В статье были рассмотрены следующие темы: описание графов, типы графов, введение по графовым алгоритмам, алгоритм нахождения кратчайшего пути в графе. Это послужит точкой входа в Ваши познания о графах.</p>
</body>
</html>
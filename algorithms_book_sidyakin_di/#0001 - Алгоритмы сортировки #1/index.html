<html>
<head>
<title>Алгоритмы - Алгоритмы Сортировки #1</title>
<link rel="stylesheet" type="text/css" href="../../css/main.css">
</head>
<body>
<p>
	Статья посвещена тому, как сортировать числовые массивы методом нахождения максимума или минимума и пузырьковой сортировки.
	Это рассмотрение основных алгоритмов сортировки, возможны и другие, но мы их рассмотрим в других статьях. Сортировать можно не только числа. 
</p>
<img src="../img/algorithms_logo_blogger.png"/>
<h1>Алгоритмы - Алгоритмы Сортировки #1.</h1>
<h2 id="Content">Содержание:</h2>
<ul class="noneVisibleMarkers">
<li><a href="#AFindingOfAMinimim">1. Нахождение Минимума.</a></li>
<li><a href="#AFindingOfAMaximum">2. Нахождение Максимума.</a></li>
<li><a href="#ABubleSorting">3. Пузырьковая Cортировка.</a></li>
<li><a href="#AConclusion">4. Заключение.</a></li>
</ul>
<h2 id="AFindingOfAMinimim">1. Нахождение Минимума.</h2>
<h3>1.1. Первое объяснение.</h3>
<p>Найдите первое минимальное число, поменяйте его местами с первым и далее повторите процедуру до последнего, не брав во внимание первое число и так далее (потом не брав во внимание первое и второе, поменяв местами второе и минимальное в оставшемся массиве, если оно меньше, потом первое, и второе, и третье и т.д.). Это алгоритм сортировки от меньшего к большему. Переставляйте на последнее место, если хотите получить алгоритм от большего к меньшему.</p>
<h3>1.2. Второе объяснение.</h3>
<p>Первого объяснения (1.1. Первое объяснение.) достаточно для тех, кто уже знает этот алгоритм, теперь рассмотрим алгоритм сортировки нахождением минимума от меньшего к большему подробнее:</p>
<ul class="noneVisibleMarkers">
	<li>1. Введите временную переменную <b><i>index</i></b> для запоминания текущего значения номера элемента массива.
	<li>2. Выполните цикл N раз, где N равно размеру массива минус единица. Введите переменную <b><i>i</i></b> для количества уже проанализированных элементов - это счётчик цикла. Объявите её для начала алгоритма на начало массива:
		<ul class="noneVisibleMarkers">
			<li>2.1. Присвойте переменной <b><i>index</i></b> значение <b><i>i</i></b>.</li>
			<li>2.2. Выполните цикл от <b><i>i+1</i></b> до конца массива, где <b><i>j</i></b> счётчик этого цикла. Далее массив будем называть <b><i>arr</i></b>, а доступ к <b><i>i</i></b>-тому элементу будем называть <b><i>arr[i]</i></b>:
				<ul class="noneVisibleMarkers">
					<li>2.2.1. Если <b><i>arr[index]</i></b> больше <b><i>j</i></b>-того элемента (<b><i>arr[index] &gt arr[j]</i></b>), то присвойте переменной <b><i>index</i></b> начение счётчика <b><i>j</i></b>, <b><i>index:=j</i></b>.</li>
				</ul>
			</li>
			<li>2.3. Обменяйте местами значения элементов массива с индексами. <b><i>index</i></b> и <b><i>i</i></b>.</li>
		</ul>
	</li>
	<li>Конец.</li>
</ul>
<p>Далее рассмотрим блок-схему алгоритма, т.к. в алгоритме не учтено присвоение счётчиков цикла:</p>
<p>Входные данные: <b>arr</b> &mdash; входной сортируемый массив.</p>
<img src="img/finding_minimum.png"/>
<p><i>Рис. 1. Блок-схема алгоритма сортировки нахождением минимума от меньшего к большему.</i></p>
<p>Также возможен алгоритм сортировки от большего к меньшему, но с другими параметрами.</p>
<h3>1.3. Третье объяснение.</h3>
Теперь рассмотрим алгоритм сортировки от меньшего к большему нахождением минимума на языке Java:
<div class="commands">
private static void sortArrMin(ArrayList&lt;Integer&gt; arr) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 1. Введите временную переменную index для запоминания текущего значения номера элемента массива.<br>
&nbsp;&nbsp;&nbsp;&nbsp;int index;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Введём переменную для обмена, запомните сортировать можно не только числа.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Integer temp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// 2. Выполните цикл N раз, где N равно размеру массива минус единица. Введите переменную i для количества уже проанализированных элементов - это счётчик цикла. Объявите её для начала алгоритма на начало массива:<br>
&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; arr.size() - 1; i++) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.1. Присвойте переменной index значение i.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = i;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.2. Выполните цикл от i+1 до конца массива, где j счётчик этого цикла. Далее массив будем называть arr, а доступ к i-тому элементу будем называть arr[i]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int j = i + 1; j &lt; arr.size(); j++ ) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.2.1. Если arr[index] больше j-того элемента (arr[index] &gt; arr[j]), то присвойте переменной index начение счётчика j, index:=j.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr.get(index) &gt; arr.get(j)) index = j;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обменяйте местами значения элементов массива с индексами. index и i.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = arr.get(index);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(index, arr.get(i));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(i, temp);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
}
</div>
<h2 id="AFindingOfAMaximum">2. Нахождение Максимума.</h2>
<h3>2.1. Первое объяснение.</h3>
<p>Алгоритм нахождения максимального элемента эквивалентен алгоритму сортировки нахождения минимального элемента, только имеет обратный смысл сортировка от большего к меньшему и от меньшего к большему.</p>
<p>Найдите первое максимальное число, поменяйте его местами с первым и далее повторите процедуру до последнего, не брав во внимание первое число и так далее (потом не брав во внимание первое и второе, поменяв местами второе и максимальное в оставшемся массиве, если оно больше, потом первое, и второе, и третье и т.д.). Это алгоритм сортировки от большему к меньшему. Переставляйте на последнее место, если хотите получить алгоритм от меньшего к большему.</p>
<h3>2.2. Второе объяснение.</h3>
<p>Первого объяснения (2.1. Первое объяснение.) достаточно для тех, кто уже знает этот алгоритм, теперь рассмотрим алгоритм сортировки нахождением максимума от меньшего к большему подробнее:</p>
<ul class="noneVisibleMarkers">
	<li>1. Введите временную переменную <b><i>index</i></b> для запоминания текущего значения номера элемента массива.
	<li>2. Выполните цикл N раз, где N равно размеру массива минус единица. Введите переменную <b><i>i</i></b> для количества уже проанализированных элементов - это счётчик цикла. Объявите её для начала алгоритма на конец массива:
		<ul class="noneVisibleMarkers">
			<li>2.1. Присвойте переменной <b><i>index</i></b> значение <b><i>i</i></b>.</li>
			<li>2.2. Выполните цикл от <b><i>0</i></b> до <b><i>размер массива - i</i></b>, где <b><i>j</i></b> счётчик этого цикла. Далее массив будем называть <b><i>arr</i></b>, а доступ к <b><i>i</i></b>-тому элементу будем называть <b><i>arr[i]</i></b>:
				<ul class="noneVisibleMarkers">
					<li>2.2.1. Если <b><i>arr[index]</i></b> меньше <b><i>j</i></b>-того элемента (<b><i>arr[index] &lt arr[j]</i></b>), то присвойте переменной <b><i>index</i></b> начение счётчика <b><i>j</i></b>, <b><i>index:=j</i></b>.</li>
				</ul>
			</li>
			<li>2.3. Обменяйте местами значения элементов массива с индексами. <b><i>index</i></b> и <b><i>размер массива - i</i></b>.</li>
		</ul>
	</li>
	<li>Конец.</li>
</ul>
<p>Далее рассмотрим блок-схему алгоритма, т.к. в алгоритме не учтено присвоение счётчиков цикла:</p>
<p>Входные данные: <b>arr</b> &mdash; входной сортируемый массив.</p>
<img src="img/finding_maximum.png"/>
<p><i>Рис. 2. Блок-схема алгоритма сортировки нахождением максимума от меньшего к большему.</i></p>
<p>Также возможен алгоритм сортировки от большего к меньшему, но с другими параметрами.</p>
<h3>2.3. Третье объяснение.</h3>
Теперь рассмотрим алгоритм сортировки от меньшего к большему нахождением максимума на языке Java:
<div class="commands">
private static void sortArrMax(ArrayList&lt;Integer&gt; arr) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// 1. Введите временную переменную index для запоминания текущего значения номера элемента массива.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int index;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Введём переменную для обмена, запомните сортировать можно не только числа.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Integer temp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// 2. Выполните цикл N раз, где N равно размеру массива минус единица. Введите переменную i для количества уже проанализированных элементов - это счётчик цикла. Объявите её для начала алгоритма на конец массива:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(int i = arr.size() - 1; i >= 0; i--) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.1. Присвойте переменной index значение i.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = i;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.2. Выполните цикл от 0 до i-1, где j счётчик этого цикла. Далее массив будем называть arr, а доступ к i-тому элементу будем называть arr[i]:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int j = i - 1; j &gt;= 0; j-- ) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.2.1. Если arr[index] больше j-того элемента (arr[index] > arr[j]), то присвойте переменной index начение счётчика j, index:=j<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr.get(index) &lt; arr.get(j)) index = j;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обменяйте местами значения элементов массива с индексами. index и i.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = arr.get(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(index, arr.get(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(i, temp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
}
</div>
<h2 id="ABubleSorting">3. Пузырьковая Сортировка.</h2>
<h3>3.1. Первое объяснение.</h3>
<p>Объяснение на примере пузырьковой сортировки от меньшего к большему:</p>
<p>
Берём последний элемент и стравнивываем его с предпоследним, если последний меньше больше предыдущего, то меняем их местами.
Применяем данное правило к новому предпослениму элементу и элементу, расположенному перед предпосленим. Повторяем это правило до первого элемента.
Снова повторяем это правило, считая, что первый элемент трогать не надо, т.к. на его место правило протолкнуло наименьший элемент. Теперь в результате этого правила протолкулся на второе место наименьший элемент в оставшейся части.
Повторяем это правило проталкивания обменом к оставшейся части массива, исключив первый и второй. И так далее, пока не осортируется массив.
Посмотрим на это правило (пузырьковую сортировку) на Анимации 1. Пузырьковая сортировка на обратно отсортированном массиве:</p>
<img src="img/buble_sorting_rev.gif" />  
<p><i>Анимация 1. Пузырьковая сортировка на обратно отсортированном массиве (применённая к обратному случаю (обратным входным данным)).</i></p>
<h3>3.2. Второе объяснение.</h3>
Первого объяснения (3.1. Первое объяснение.) достаточно для тех, кто уже знает этот алгоритм, теперь рассмотрим алгоритм пузырьковой сортировки от меньшего к большему подробнее:
<ul class="noneVisibleMarkers">
	<li>1. Введите временную переменную temp для запоминания текущего значения элемента массива.
	<li>2. Введём цикл для перемещения пузырьков, равный по повторениям (Размер массива arr).:
		<ul class="noneVisibleMarkers">
			<li>2.1. Просмотрим в цикле все элементы массива, просматриваются два элемента, поэтому повторений будет (Размер массива - 1). Элементы просматриваются с конца.
				<ul class="noneVisibleMarkers">
					<li>2.1.1. Вычислим индекс предыдущего элемента за анализируемым.</li>
					<li>2.1.2. Если текущий элемент больше предыдущего за ним, то меняем их местами.</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>Конец.</li>
</ul>
<p>Далее рассмотрим блок-схему алгоритма, т.к. в алгоритме не учтено присвоение счётчиков цикла:</p>
<p>Входные данные: <b>arr</b> &mdash; входной сортируемый массив.</p>
<img src="img/buble_sorting.png"/>
<p><i>Рис. 3. Блок-схема алгоритма сортировки пузырьком от меньшего к большему.</i></p>
<h3>3.3. Третье объяснение.</h3>
Теперь рассмотрим алгоритм сортировки пузырьком от меньшего к большему на языке Java:
<div class="commands">
private static void sortArrBuble(ArrayList&lt;Integer&gt; arr) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// 1. Введите временную переменную temp для запоминания текущего значения элемента массива.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Integer temp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// 2. Введём цикл для перемещения пузырьков, равный по повторениям (Размер массива arr).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; arr.size() - 1; i++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.1. Просмотрим в цикле все элементы массива, просматриваются два элемента, поэтому повторений будет (Размер массива - 1). Элементы просматриваются с конца.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int j = arr.size() - 1; j &gt; i; j--)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.1.1. Вычислим индекс предыдущего элемента за анализируемым.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int decJ = j - 1;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.1.2. Если текущий элемент больше предыдущего за ним, то меняем их местами.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr.get(j).intValue() &lt; arr.get(decJ).intValue()) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Меняем их местами.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = arr.get(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(j, arr.get(decJ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.set(decJ, temp);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}
</div>
<h2 id="AConclusion">4. Заключение.</h2>
Мы рассмотрели 3 алгоритма сортировки, как видно, у них одинаковая сложность.
<div class="information">
	<p>В филологии: Если разделить на объекты, то есть одинаковый по сложности путь решения математической задачи на процессоре.</p>
</div>
</body>
</html>